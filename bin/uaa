#!/usr/bin/env ruby
# Cloud Foundry 2012.02.03 Beta
# Copyright (c) [2009-2012] VMware, Inc. All Rights Reserved.
#
# This product is licensed to you under the Apache License, Version 2.0 (the "License").
# You may not use this product except in compliance with the License.
#
# This product includes a number of subcomponents with
# separate copyright notices and license terms. Your use of these
# subcomponents is subject to the terms and conditions of the
# subcomponent's license, as noted in the LICENSE file.
#

require 'yaml'
require 'nats/client'
require 'vcap/common'
require 'vcap/logging'

VCAP::Logging.setup_from_config()
logger = VCAP::Logging.logger('uaa')

root=File.absolute_path(File.join(File.dirname(__FILE__), ".."))
if File.exist?(root) then
  logger.info("Using root=#{root}")
else
  abort("#{root} is not a directory.  Do you need to init submodules?") 
end

cfg_path = ENV['CLOUD_FOUNDRY_CONFIG_PATH'] ? ENV['CLOUD_FOUNDRY_CONFIG_PATH'] : File.join(root, "config")

logger.info("Config path: #{cfg_path}")

cfg_file = File.join(cfg_path, "uaa.yml")

config = {"uaa"=>{}, "varz"=>{}}
File.exist?(cfg_file) && File.open(cfg_file) do |f|
  logger.info("Loading config file from #{cfg_file}")
  config.update(YAML.load(f))
end
config["varz"]["username"] ||= VCAP.secure_uuid
config["varz"]["password"] ||= VCAP.secure_uuid

logger.info("Launching tomcat from PID=#{Process.pid}")

maven_opts = "-DPID=$$"
config["jvm_args"] && maven_opts += " " + config["jvm_args"]
config["spring_profiles"] && maven_opts += " -Dspring.profiles.active=" + config["spring_profiles"]
maven_opts += """ -Dvarz.username=#{config["varz"]["username"]} -Dvarz.password=#{config["varz"]["password"]}"""
logger.info("Tomcat JVM args: #{maven_opts}")

# The form of this next bit is very sensitive.  We need the PID for
# logging so we need to exec from the shell to stay in the same
# process...
pid = spawn("export MAVEN_OPTS=\"#{maven_opts}\" && exec mvn tomcat:run -P vcap", {:chdir=>root})

logger.info("Tomcat PID = #{pid}")

pidfile = config["pid"]
if !pidfile then
  Process.kill("ABRT", pid)
  abort("No 'pid' file path defined in #{cfg_file}")
end
File.open(pidfile, 'w') {|f| f.write(pid) }

logger.info("Preparing to launch NATS from #{pid}")

router_msg = { :host => config["uaa"]["host"]||"localhost", :port => config["uaa"]["port"]||8080, :uris => config["uaa"]["uris"]||["uaa.vcap.me"], :tags => {:component => "UAA"} }
router_json = Yajl::Encoder.encode(router_msg)
discover_msg = { :type => 'UAA', 
  :host => "%s:%s" % [config["uaa"]["host"]||"localhost",  config["uaa"]["port"]||8080],
  :index => 0,
  :credentials => [config["varz"]["username"], config["varz"]["password"]]
}
discover_json = Yajl::Encoder.encode(discover_msg)
logger.info("Sending Router info to NATS: json="+router_json)
mbus = config["mbus"] || "nats://localhost:4222/"

Thread.new do

  # NATS will block and we want to wait for the tomcat process so this
  # has to go in a new thread

  logger.info("Launching NATS from uaa")
  NATS.start(:uri => mbus) do

    NATS.subscribe('vcap.component.discover') do |msg, reply|
      NATS.publish(reply, discover_json)
    end

    # Also announce ourselves on startup..
    NATS.publish('vcap.component.announce', discover_json)

    # Tell all current routers where to find us.
    NATS.publish('router.register', router_json)
    # Listen for router starts/restarts
    NATS.subscribe('router.start') { NATS.publish('router.register', router_json) }
  end

end

Process.wait(pid)
